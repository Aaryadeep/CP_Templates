{
	"SegmentTreeForSinglePointUpdate": {
		"prefix": "SegtreeSimple",
		"body": [
			"template <typename T, typename T2>",
			"class SegmentTree {",
			"  private:",
			"   vector<T2>& arr;",
			"   vector<T> tree;",
			"   const T NEUTRO_ELE = T{0};",
			"   int n;",
			"",
			"   inline T combine(T a, T b) {",
			"      return T{a + b};",
			"   }",
			"   inline T buildLeaf(T2 a) {",
			"      return a;",
			"   }",
			"",
			"   void build(int node, int start, int end) {",
			"      if (start == end) {",
			"         tree[node] = buildLeaf(arr[start]);",
			"      } else {",
			"         int mid = (start + end) >> 1;",
			"         build(2 * node + 1, start, mid);",
			"         build(2 * node + 2, mid + 1, end);",
			"         tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"      }",
			"   }",
			"",
			"   void updateNode(int node, int start, int end, int idx, T2 value) {",
			"      if (start == end) {",
			"         tree[node] = buildLeaf(value);",
			"      } else {",
			"         int mid = (start + end) >> 1;",
			"         if (idx >= start && idx <= mid) {",
			"            updateNode(2 * node + 1, start, mid, idx, value);",
			"         } else {",
			"            updateNode(2 * node + 2, mid + 1, end, idx, value);",
			"         }",
			"         tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"      }",
			"   }",
			"",
			"   T query(int node, int start, int end, int queryStart, int queryEnd) {",
			"      if (start > queryEnd || end < queryStart) {",
			"         return NEUTRO_ELE;",
			"      } else if (start >= queryStart && end <= queryEnd) {",
			"         return tree[node];",
			"      } else {",
			"         int mid = (start + end) >> 1;",
			"         T left = query(2 * node + 1, start, mid, queryStart, queryEnd);",
			"         T right = query(2 * node + 2, mid + 1, end, queryStart, queryEnd);",
			"         return combine(left, right);",
			"      }",
			"   }",
			"",
			"  public:",
			"   SegmentTree(vector<T2>& inputArray) : arr(inputArray) {",
			"      n = arr.size();",
			"      tree.assign(4 * n, NEUTRO_ELE);",
			"      build(0, 0, n - 1);",
			"   }",
			"   void update(int idx, T2 value) {",
			"      updateNode(0, 0, n - 1, idx, value);",
			"   }",
			"   T query(int queryStart, int queryEnd) {",
			"      return query(0, 0, n - 1, queryStart, queryEnd);",
			"   }",
			"   int find(int k) {",
			"      return 2;",
			"   }",
			"};"
		],
		"description": "SegmentTreeForSinglePointUpdate"
	},
	"PrimeFactorizationForMultipleQueries": {
		"prefix": "PrimeFactorization",
		"body": [
			"const int MAXN = 10000000;",
			"int spf[MAXN + 1];",
			"",
			"void sieve() {",
			"   for (int i = 1; i <= MAXN; ++i) {",
			"      spf[i] = i;",
			"   }",
			"   for (int i = 2; i * i <= MAXN; ++i) {",
			"      if (spf[i] == i) {",
			"         for (int j = i * i; j <= MAXN; j += i) {",
			"            if (spf[j] == j) {",
			"               spf[j] = i;",
			"            }",
			"         }",
			"      }",
			"   }",
			"}"
		],
		"description": "PrimeFactorizationForMultipleQueries"
	},
	"powmodAndCombinatorics": {
		"prefix": "Combinatrics",
		"body": [
			"// nCr % mod Combinatrics Feramts Theorem",
			"vector<ll> fact(100005,0);",
			"ll powmod(ll a, ll b, ll p){",
			"    a %= p;",
			"    if (a == 0) return 0;",
			"    ll product = 1;",
			"    while(b > 0){",
			"        if (b&1){    // you can also use b % 2 == 1",
			"            product *= a;",
			"            product %= p;",
			"            --b;",
			"        }",
			"        a *= a;",
			"        a %= p;",
			"        b /= 2;    // you can also use b >> 1",
			"    }",
			"    return product;",
			"}",
			"ll inv(ll a, ll p){",
			"    return powmod(a, p-2, p);",
			"}",
			"ll nCk(ll n, ll k, ll p){",
			"    return ((fact[n] * inv(fact[k], p) % p) * inv(fact[n-k], p)) % p;",
			"}"
		],
		"description": "powmodAndCombinatorics"
	},
	"Lazy_SegmentTree": {
		"prefix": "Lazy_segtree",
		"body": [
			"template <typename T, typename T2, typename T3>",
			"class SegmentTree {",
			"  private:",
			"   vector<T3>& arr;",
			"   vector<T> tree;",
			"   vector<T2> lazy;",
			"   int n;",
			"   const T2 NO_OPS_LAZY = 0;",
			"   const T NEUTRAL_ELEMENT = 0;",
			"",
			"   inline T combine(T a, T b) {",
			"      return a + b;",
			"   }",
			"   inline void combineLazy(T2& a, T2 b) {",
			"      a += b;",
			"   }",
			"   inline void mapp(T& s, T2 f, int len) {",
			"      if (f == NO_OPS_LAZY) return;",
			"      s += f * len;",
			"   }",
			"   inline T buildNode(T3 a) {",
			"      return T{a};",
			"   }",
			"",
			"   void build(int node, int start, int end) {",
			"      if (start == end) {",
			"         tree[node] = buildNode(arr[start]);",
			"      } else {",
			"         int mid = (start + end) >> 1;",
			"         build(2 * node + 1, start, mid);",
			"         build(2 * node + 2, mid + 1, end);",
			"         tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"      }",
			"   }",
			"",
			"   void propogate(int node, int start, int end) {",
			"      if (start == end) return;",
			"      int mid = (start + end) >> 1;",
			"      const int left = 2 * node + 1, right = 2 * node + 2;",
			"      combineLazy(lazy[left], lazy[node]);",
			"      mapp(tree[left], lazy[node], mid - start + 1);",
			"      combineLazy(lazy[right], lazy[node]);",
			"      mapp(tree[right], lazy[node], end - mid);",
			"      lazy[node] = NO_OPS_LAZY;",
			"   }",
			"",
			"   void updateSegment(int node, int start, int end, int l, int r, T2 val) {",
			"      propogate(node, start, end);",
			"      if (start > r || end < l) return;",
			"      if (start >= l && end <= r) {",
			"         combineLazy(lazy[node], val);",
			"         mapp(tree[node], val, end - start + 1);",
			"         return;",
			"      }",
			"      int mid = (start + end) >> 1;",
			"      updateSegment(2 * node + 1, start, mid, l, r, val);",
			"      updateSegment(2 * node + 2, mid + 1, end, l, r, val);",
			"      tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
			"   }",
			"",
			"   T rangeQuery(int node, int start, int end, int l, int r) {",
			"      propogate(node, start, end);",
			"      if (start > r || end < l) return NEUTRAL_ELEMENT;",
			"      if (start >= l && end <= r) {",
			"         return tree[node];",
			"      }",
			"      int mid = (start + end) >> 1;",
			"      T left = rangeQuery(2 * node + 1, start, mid, l, r);",
			"      T right = rangeQuery(2 * node + 2, mid + 1, end, l, r);",
			"      return combine(left, right);",
			"   }",
			"",
			"  public:",
			"   SegmentTree(vector<T3>& inputArray) : arr(inputArray) {",
			"      n = arr.size();",
			"      const int sz = 1 << ((int)ceil(log2(n)) + 1);",
			"      tree.assign(sz, NEUTRAL_ELEMENT);",
			"      lazy.assign(sz, NO_OPS_LAZY);",
			"      // build(0, 0, n - 1);",
			"   }",
			"",
			"   void updateSegment(int l, int r, T2 val) {",
			"      updateSegment(0, 0, n - 1, l, r, val);",
			"   }",
			"",
			"   T rangeQuery(int l, int r) {",
			"      return rangeQuery(0, 0, n - 1, l, r);",
			"   }",
			"};"
		],
		"description": "Lazy_SegmentTree"
	},
	"Main": {
		"prefix": "MainCode",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"using namespace std;",
			"template <typename T>",
			"inline void inp(vector<T>& a) {",
			"   for (auto& it : a) cin >> it;",
			"}",
			"",
			"int main() {",
			"   cin.tie(0)->sync_with_stdio(0);",
			"   int t = 1;",
			"   cin >> t;",
			"   while (t--) {",
			"",
			"   }",
			"   return 0;",
			"}"
		],
		"description": "Main"
	},
	"Modular Template": {
		"prefix": "ModularTemplate",
		"body": [
			"template <typename T>",
			"T inverse(T a, T m) {",
			"   T u = 0, v = 1;",
			"   while (a != 0) {",
			"      T t = m / a;",
			"      m -= t * a;",
			"      swap(a, m);",
			"      u -= t * v;",
			"      swap(u, v);",
			"   }",
			"   assert(m == 1);",
			"   return u;",
			"}",
			"",
			"template <typename T>",
			"class Modular {",
			"  public:",
			"   using Type = typename decay<decltype(T::value)>::type;",
			"",
			"   constexpr Modular() : value() {}",
			"   template <typename U>",
			"   Modular(const U& x) {",
			"      value = normalize(x);",
			"   }",
			"",
			"   template <typename U>",
			"   static Type normalize(const U& x) {",
			"      Type v;",
			"      if (-mod() <= x && x < mod())",
			"         v = static_cast<Type>(x);",
			"      else",
			"         v = static_cast<Type>(x % mod());",
			"      if (v < 0) v += mod();",
			"      return v;",
			"   }",
			"",
			"   const Type& operator()() const { return value; }",
			"   template <typename U>",
			"   explicit operator U() const { return static_cast<U>(value); }",
			"   constexpr static Type mod() { return T::value; }",
			"",
			"   Modular& operator+=(const Modular& other) {",
			"      if ((value += other.value) >= mod()) value -= mod();",
			"      return *this;",
			"   }",
			"   Modular& operator-=(const Modular& other) {",
			"      if ((value -= other.value) < 0) value += mod();",
			"      return *this;",
			"   }",
			"   template <typename U>",
			"   Modular& operator+=(const U& other) { return *this += Modular(other); }",
			"   template <typename U>",
			"   Modular& operator-=(const U& other) { return *this -= Modular(other); }",
			"   Modular& operator++() { return *this += 1; }",
			"   Modular& operator--() { return *this -= 1; }",
			"   Modular operator++(int) {",
			"      Modular result(*this);",
			"      *this += 1;",
			"      return result;",
			"   }",
			"   Modular operator--(int) {",
			"      Modular result(*this);",
			"      *this -= 1;",
			"      return result;",
			"   }",
			"   Modular operator-() const { return Modular(-value); }",
			"",
			"   template <typename U = T>",
			"   typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"      return *this;",
			"   }",
			"   template <typename U = T>",
			"   typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"      long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
			"      value = normalize(value * rhs.value - q * mod());",
			"      return *this;",
			"   }",
			"   template <typename U = T>",
			"   typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"      value = normalize(value * rhs.value);",
			"      return *this;",
			"   }",
			"",
			"   Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"   friend const Type& abs(const Modular& x) { return x.value; }",
			"",
			"   template <typename U>",
			"   friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"   template <typename U>",
			"   friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"   template <typename V, typename U>",
			"   friend V& operator>>(V& stream, Modular<U>& number);",
			"",
			"  private:",
			"   Type value;",
			"};",
			"",
			"template <typename T>",
			"bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U>",
			"bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U>",
			"bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T>",
			"bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T>",
			"bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T>",
			"Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template <typename T, typename U>",
			"Modular<T> power(const Modular<T>& a, const U& b) {",
			"   assert(b >= 0);",
			"   Modular<T> x = a, res = 1;",
			"   U p = b;",
			"   while (p > 0) {",
			"      if (p & 1) res *= x;",
			"      x *= x;",
			"      p >>= 1;",
			"   }",
			"   return res;",
			"}",
			"",
			"template <typename T>",
			"bool IsZero(const Modular<T>& number) {",
			"   return number() == 0;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T>& number) {",
			"   return to_string(number());",
			"}",
			"",
			"// U == std::ostream? but done this way because of fastoutput",
			"template <typename U, typename T>",
			"U& operator<<(U& stream, const Modular<T>& number) {",
			"   return stream << number();",
			"}",
			"",
			"// U == std::istream? but done this way because of fastinput",
			"template <typename U, typename T>",
			"U& operator>>(U& stream, Modular<T>& number) {",
			"   typename common_type<typename Modular<T>::Type, long long>::type x;",
			"   stream >> x;",
			"   number.value = Modular<T>::normalize(x);",
			"   return stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"",
			"constexpr int md = 998244353;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
			"",
			"/*vector<Mint> fact(1, 1);",
			"vector<Mint> inv_fact(1, 1);",
			"",
			"Mint C(int n, int k) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while ((int) fact.size() < n + 1) {",
			"    fact.push_back(fact.back() * (int) fact.size());",
			"    inv_fact.push_back(1 / fact.back());",
			"  }",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];",
			"}*/"
		],
		"description": "Modular Template"
	},
	"DSU": {
		"prefix": "Dsu",
		"body": [
			"class DisjointSets {",
			"  private:",
			"   vector<int> parents;",
			"   vector<int> sizes;",
			"",
			"  public:",
			"   DisjointSets(int size) : parents(size), sizes(size, 1) {",
			"      for (int i = 0; i < size; i++) {",
			"         parents[i] = i;",
			"      }",
			"   }",
			"",
			"   /** @return the \"representative\" node in x's component */",
			"   int find(int x) {",
			"      return parents[x] == x ? x : (parents[x] = find(parents[x]));",
			"   }",
			"",
			"   /** @return whether the merge changed connectivity */",
			"   bool unite(int x, int y) {",
			"      int x_root = find(x);",
			"      int y_root = find(y);",
			"      if (x_root == y_root) return false;",
			"",
			"      if (sizes[x_root] < sizes[y_root]) swap(x_root, y_root);",
			"      sizes[x_root] += sizes[y_root];",
			"      parents[y_root] = x_root;",
			"      return true;",
			"   }",
			"",
			"   /** @return whether x and y are in the same connected component */",
			"   bool connected(int x, int y) { return find(x) == find(y); }",
			"",
			"   /** @return size of component of x */",
			"   int size(int x) {",
			"      return sizes[find(x)];",
			"   }",
			"};"
		],
		"description": "DSU"
	},
	"Parity of permutation": {
		"prefix": "ParityOfPerm",
		"body": [
			"bool parity(const vector<int> &p) {",
			"    int n = p.size();",
			"    if (n == 1) return false;",
			"    vector<int> cur(n);",
			"    vector<int> inv_cur(n);",
			"    iota(cur.begin(), cur.end(), 0);",
			"    iota(inv_cur.begin(), inv_cur.end(), 0);",
			"    auto do_cycle = [&](int i, int j, int k) {",
			"        int tmp = cur[k];",
			"        cur[k] = cur[j];",
			"        cur[j] = cur[i];",
			"        cur[i] = tmp;",
			"",
			"        inv_cur[cur[i]] = i;",
			"        inv_cur[cur[j]] = j;",
			"        inv_cur[cur[k]] = k;",
			"    };",
			"    for (int i = 0; i < n - 2; i++) {",
			"        if (cur[i] != p[i]) {",
			"            int j = inv_cur[p[i]];",
			"            if (j != n - 1) {",
			"                do_cycle(n - 1, j, i);",
			"            } else {",
			"                do_cycle(n - 2, j, i);",
			"            }",
			"        }",
			"    }",
			"    return cur[n - 1] != p[n - 1];",
			"}"
		],
		"description": "Parity of permutation"
	},
	"Modified Kadane": {
		"prefix": "KadanesModified",
		"body": [
			"// modified kadane to find max_subarray_sum of size between a to b",
			"ll max_subarray_of_size_a_to_b(vector<int>& arr , int a, int b) {",
			"    int n = arr.size();",
			"    ",
			"    vector<ll> prefix_sums(n + 1, 0);",
			"    for (int i = 1; i <= n; ++i) {",
			"        prefix_sums[i] = prefix_sums[i - 1] + arr[i-1];",
			"    }",
			"    ",
			"    int d = b - a;",
			"    deque<pair<ll, int>> deq;",
			"    ll answer = -1e16; // INT64_MIN",
			"    for (int i = a; i <= n + d; ++i) {",
			"        if (!deq.empty() && deq.front().second < i - d)",
			"            deq.pop_front();",
			"        ",
			"        if (i <= n) {",
			"            while (!deq.empty() && deq.back().first <= prefix_sums[i])",
			"                deq.pop_back();",
			"            deq.push_back({prefix_sums[i], i});",
			"        }",
			"        if (i >= b)",
			"            answer = max(answer, (deq.front().first - prefix_sums[i - b]));",
			"    }",
			"    return answer;",
			"}"
		],
		"description": "Modified Kadane"
	},
	"Coordinate_Compression": {
		"prefix": "CompressCoordinate",
		"body": [
			"struct Compress {",
			"   int sz;",
			"   vector<int> p;",
			"   Compress(const vector<int>& a) : p(a) {",
			"      p = a;",
			"      sort(p.begin(), p.end());",
			"      p.erase(unique(p.begin(), p.end()), p.end());",
			"   }",
			"   inline int getComp(int x) {",
			"      return lower_bound(p.begin(), p.end(), x) - p.begin();",
			"   }",
			"   inline int getOrig(int x) {",
			"      return p[x];",
			"   }",
			"};"
		],
		"description": "Coordinate_Compression"
	},
	"TwoPointerNotes": {
		"prefix": "TwoPointer",
		"body": [
			"/*",
			" Two Pointer:",
			" Generalise: iterate over R",
			" Move L starting from -1, move L to L+1 if L+1 satisfy same condn as L",
			"*/"
		],
		"description": "TwoPointerNotes"
	},
	"BoilerPlate Code": {
		"prefix": "MMain",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main() {",
			"  cin.tie(0)->sync_with_stdio(0);",
			"  int t = 1;",
			"  cin >> t;",
			"  while (t--) {",
			"    ",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "BoilerPlate Code"
	},
	"KMP_PrefixTable": {
		"prefix": "KMP_PrefixTable",
		"body": [
			"vector<int> PrefixTable(string s) {",
			"  const int n = s.size();",
			"  vector<int> pi(n, 0);",
			"",
			"  for (int i = 1; i < n; i++) {",
			"    int j = pi[i - 1];",
			"    while (j && s[i] != s[j]) j = pi[j - 1];",
			"    pi[i] = (s[i] == s[j] ? j + 1 : j);",
			"  }",
			"",
			"  return pi;",
			"}"
		],
		"description": "KMP_PrefixTable"
	}
}
